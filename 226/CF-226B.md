<center> B.淘气石堆</center>
<center> 时间限制：2秒</center>
<center> 空间限制：256M</center>
[题目链接](https://codeforces.com/problemset/problem/226/B)

这有 $n$ 堆石子，每堆分别有 $a_1,a_2,\dots,a_n$ 个石子放在你面前的桌子上。

在每次移动中，你可以选择一堆石子，并把它合并到其他的堆上。如果你把第 $i$ 堆加到第 $j$ 堆上，那么第 $j$ 堆会增加当前第 $i$ 堆拥有的石子数，并且第 $i$ 堆将不会继续存在。这样操作的代价是第 $i$ 堆的石子数。

你的任务是考虑把这些石子合成一堆的最小代价。

为了增加一些难度，我们规定，合并的石头堆最多被合并 $k$ 次（在这之后，你只能把这一堆合并到其他堆上）。

此外，你将会被询问 $q$ 次，每次给你可能相同的 $k$ 。

你的任务是对于这 $q$ 个询问，给出最小花费。

### 输入

第一行包含一个整数 $n$ ($1 \leq n \leq 10^5$) - 石头堆的数量，第二行包含 $n$ 个用空格分开的整数：$a_1,a_2,\dots,a_n$($1 \leq a_i \leq 10^9$)  - 初始的石头堆的石头数量。

第三行包含一个整数 $q$ ($1 \leq q \leq 10^5$) - 询问的次数。最后一行包含 $q$ 个用空格分开的整数：$k_1,k_2,\dots,k_q$($1 \leq k_i \leq 10^5$) - 表示每个不同询问对应的 $k$ 。注意 $k_i$ 可能会重复。

### 输出

输出 $q$ 个用空格分开的整数 - 表示对于每个按照顺序给出的输入对应的输出。

请不要用 $\%lld$ 作为c++ 64位整数的输入或者输出。最好使用 $cin, cout$ 流，或者使用 $\%I64d$ 。

